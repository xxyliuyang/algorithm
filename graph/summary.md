图相关算法

### 1,图表示：边是否有方向，边是否带权重
#### 1.1 邻接矩阵：
- n*n的矩阵，表示两个节点是否连接；
- 优点：容易查找两个点的连接关系；方便计算每个点的出度和入度
- 缺点：浪费空间，比较稀疏；比较费时，遍历的时候，需要遍历整个矩阵
#### 1.2 邻接表：
- 每个节点是一个链表，保存节点连接的点
- 优点：方便查找每个点相连的点；可以比价方便计算度
- 缺点：不方便查找任意两个点的连接关系

#### 2，图的遍历
#### 2.1 DFS
- 伪代码: 使用堆栈实现

`
void DFS（vertex v):

    vistied[v] = true
    for v每个邻接点w:
        if !visted[w]:
            DFS(W)
`
- 时间复杂度：N个点，E条边。邻接表是o(N+E), 邻接矩阵是o(N^2)
- 是一种递归的搜索过程；

#### 2.2 BFS
- 伪代码：使用队列实现

`
queue Q
void BFS（vertex v):

    visited[v] = true
    Q.push(v)
    while Q中有值：
        v = Q.pop()
        for v 的每个邻接点 w：
            visited[w] = true
            Q.push(w)
`
- 时间复杂度：N个点，E条边。邻接表是o(N+E), 邻接矩阵是o(N^2)
- 是一种数据结构搜索的过程；适合找最短和最小问题；但是比较耗内存

### 3,图是否有环：
- DFS判断：一条深度遍历路线中如果有结点被第二次访问到，那么有环。我们用一个变量来标记某结点的访问状态（未访问，访问过，其后结点都被访问过），然后判断每一个结点的深度遍历路线即可。

### 4，Disjoint Set Union (DSU) data structure:一种数据结构，并查集
https://zhuanlan.zhihu.com/p/93647900
- 用途：涉及到将n 个不同的元素分成一组不相交的子集合（disjoint subset）。  所谓的不相交（disjoint）， 又被称为nonoverlapping subset。 并查集（亦称为不相交集合） support 2个重要的operations：
（1）Find (x)操作： 寻找给定的元素属于哪一个（唯一的）子集合。 这个Find 操作的返回的含有x的子集合S中 一个能够代表这个子集合S的item(一般是S的最小的成员)。 
我们可以通过比较2个Find 操作， 即find(x) 和 find(y) 来比较x 和 y 是否在同一个子集合中。

（2）Union 操作： 将两个subset 合并成一个更大的subset。

（3）路径压缩：既然我们只关心一个元素对应的根节点，那我们希望每个元素到根节点的路径尽可能短，最好只需要一步，像这样：
（4）按秩合并：合并后，树会比较简单（深度低）。用一个数组rank[]记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的子树的深度）。一开始，把所有元素的rank（秩）设为1。合并时比较两个根节点，把rank较小者往较大者上合并。

