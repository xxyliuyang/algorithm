#### 回溯法介绍
https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247494117&idx=2&sn=fbba964bfa8a08e531a289392403a5d5&scene=21#wechat_redirect

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```


#### 关键点
##### 1， 是否需要start index
- 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex。

##### 2， start index每次搜索是否需要加一
- 看是否可以重复去值，如果可以重复，则不需要加一；否则需要加一；
- 如果有剪枝操作，则可以加上step（有的位置就不用搜索了）

##### 3， 确定回溯法的深度、宽度
- 搜索过程中横向搜索-宽度，纵向搜索-深度

##### 4， 什么时候递归函数需要返回值
- 如果需要搜索整颗二叉树且不用处理递归返回值，递归函数就不要返回值。
- 如果需要搜索整颗二叉树且需要处理递归返回值，递归函数就需要返回值。
- 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。

#### 子集问题关键点
##### 1，什么结果是需要的
- 那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点。
##### 2，如何去重：数组有重复，但是子集是不需要重复。（属于同一层遍历不能重复）
- 由于子集与排列问题不一样，每次递归的时候不是从0开始，所以有两中方法规避重复
  - 方法一，万能方法：使用一回溯的数组记录当前位置是否被使用过。
  - 方法二，条件判断：不是当前层的递归的开始位置，同时与上一个位置的相同（i != start and  i > 0 and nums[i] == nums[i-1]）
https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247485435&idx=1&sn=6db97ae35adf8e983aa41102dc68dca8&scene=21#wechat_redirect

#### 排列问题
##### 1, 什么结果是需要的
- 每次遍历的时候需要减除已经选择的元素，没有start，每次更换遍历的对象。

##### 2，如何去重：数组有重复，但是子集是不需要重复。（属于同一层遍历不能重复）
- 由于子集与排列问题不一样，每次递归的时候不是从0开始，所以只有中方法规避重复
  - 方法一，万能方法：使用一回溯的数组记录当前位置是否被使用过。
  - 方法二，条件判断：行不通
##### 3，同层去重、与同支去重
  - 同层： used[i - 1] == false，说明同一树层nums[i - 1]使用过
    - i > 0 and nums[i] == nums[i-1] and used[i-1] == False
  - 同支：used[i - 1] == true，说明同一树支nums[i - 1]使用过
    - i > 0 and nums[i] == nums[i-1] and used[i-1] == True
